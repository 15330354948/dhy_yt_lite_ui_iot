define(["./arrayFill","./BoundingSphere","./Cartesian2","./Cartesian3","./ComponentDatatype","./defaultValue","./defined","./DeveloperError","./Ellipsoid","./Geometry","./GeometryAttribute","./GeometryAttributes","./GeometryOffsetAttribute","./IndexDatatype","./Math","./PrimitiveType","./VertexFormat"],function(t,e,r,a,n,i,o,s,f,c,u,l,p,m,d,v,y){"use strict";var w=new a,A=new a,h=new a,b=new a,P=new a,_=new a(1,1,1),g=Math.cos,k=Math.sin;function F(t){t=i(t,i.EMPTY_OBJECT);var e=i(t.radii,_),r=Math.round(i(t.stackPartitions,64)),n=Math.round(i(t.slicePartitions,64)),f=i(t.vertexFormat,y.DEFAULT);if(n<3)throw new s("options.slicePartitions cannot be less than three.");if(r<3)throw new s("options.stackPartitions cannot be less than three.");if(o(t.offsetAttribute)&&t.offsetAttribute===p.TOP)throw new s("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=a.clone(e),this._stackPartitions=r,this._slicePartitions=n,this._vertexFormat=y.clone(f),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}F.packedLength=a.packedLength+y.packedLength+3,F.pack=function(t,e,r){if(!o(t))throw new s("value is required");if(!o(e))throw new s("array is required");return r=i(r,0),a.pack(t._radii,e,r),r+=a.packedLength,y.pack(t._vertexFormat,e,r),r+=y.packedLength,e[r++]=t._stackPartitions,e[r++]=t._slicePartitions,e[r]=i(t._offsetAttribute,-1),e};var T,O=new a,x=new y,L={radii:O,vertexFormat:x,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};return F.unpack=function(t,e,r){if(!o(t))throw new s("array is required");e=i(e,0);var n=a.unpack(t,e,O);e+=a.packedLength;var f=y.unpack(t,e,x);e+=y.packedLength;var c=t[e++],u=t[e++],l=t[e];return o(r)?(r._radii=a.clone(n,r._radii),r._vertexFormat=y.clone(f,r._vertexFormat),r._stackPartitions=c,r._slicePartitions=u,r._offsetAttribute=-1===l?void 0:l,r):(L.stackPartitions=c,L.slicePartitions=u,L.offsetAttribute=-1===l?void 0:l,new F(L))},F.createGeometry=function(i){var s=i._radii;if(!(s.x<=0||s.y<=0||s.z<=0)){var y,_,F=f.fromCartesian3(s),T=i._vertexFormat,O=i._slicePartitions+1,x=i._stackPartitions+1,L=x*O,E=new Float64Array(3*L),N=6*(O-1)*(x-2),D=m.createTypedArray(L,N),I=T.normal?new Float32Array(3*L):void 0,M=T.tangent?new Float32Array(3*L):void 0,z=T.bitangent?new Float32Array(3*L):void 0,G=T.st?new Float32Array(2*L):void 0,S=new Array(O),U=new Array(O),C=0;for(y=0;y<O;y++){var B=d.TWO_PI*y/(O-1);S[y]=g(B),U[y]=k(B),E[C++]=0,E[C++]=0,E[C++]=s.z}for(y=1;y<x-1;y++){var q=Math.PI*y/(x-1),Y=k(q),V=s.x*Y,W=s.y*Y,J=s.z*g(q);for(_=0;_<O;_++)E[C++]=S[_]*V,E[C++]=U[_]*W,E[C++]=J}for(y=0;y<O;y++)E[C++]=0,E[C++]=0,E[C++]=-s.z;var R=new l;T.position&&(R.position=new u({componentDatatype:n.DOUBLE,componentsPerAttribute:3,values:E}));var X,Z,j=0,H=0,K=0,Q=0;if(T.st||T.normal||T.tangent||T.bitangent){for(y=0;y<L;y++){var $=a.fromArray(E,3*y,w),tt=F.geodeticSurfaceNormal($,A);if(T.st){var et=r.negate(tt,P);r.magnitude(et)<d.EPSILON6&&((C=3*(y+O*Math.floor(.5*x)))>E.length&&(C=3*(y-O*Math.floor(.5*x))),a.fromArray(E,C,et),F.geodeticSurfaceNormal(et,et),r.negate(et,et)),G[j++]=Math.atan2(et.y,et.x)/d.TWO_PI+.5,G[j++]=Math.asin(tt.z)/Math.PI+.5}if(T.normal&&(I[H++]=tt.x,I[H++]=tt.y,I[H++]=tt.z),T.tangent||T.bitangent){var rt=h;if(y<O||y>L-O-1?(a.cross(a.UNIT_X,tt,rt),a.normalize(rt,rt)):(a.cross(a.UNIT_Z,tt,rt),a.normalize(rt,rt)),T.tangent&&(M[K++]=rt.x,M[K++]=rt.y,M[K++]=rt.z),T.bitangent){var at=a.cross(tt,rt,b);a.normalize(at,at),z[Q++]=at.x,z[Q++]=at.y,z[Q++]=at.z}}}T.st&&(R.st=new u({componentDatatype:n.FLOAT,componentsPerAttribute:2,values:G})),T.normal&&(R.normal=new u({componentDatatype:n.FLOAT,componentsPerAttribute:3,values:I})),T.tangent&&(R.tangent=new u({componentDatatype:n.FLOAT,componentsPerAttribute:3,values:M})),T.bitangent&&(R.bitangent=new u({componentDatatype:n.FLOAT,componentsPerAttribute:3,values:z}))}if(o(i._offsetAttribute)){var nt=E.length,it=new Uint8Array(nt/3),ot=i._offsetAttribute===p.NONE?0:1;t(it,ot),R.applyOffset=new u({componentDatatype:n.UNSIGNED_BYTE,componentsPerAttribute:1,values:it})}for(C=0,_=0;_<O-1;_++)D[C++]=O+_,D[C++]=O+_+1,D[C++]=_+1;for(y=1;y<x-2;y++)for(X=y*O,Z=(y+1)*O,_=0;_<O-1;_++)D[C++]=Z+_,D[C++]=Z+_+1,D[C++]=X+_+1,D[C++]=Z+_,D[C++]=X+_+1,D[C++]=X+_;for(X=(y=x-2)*O,Z=(y+1)*O,_=0;_<O-1;_++)D[C++]=Z+_,D[C++]=X+_+1,D[C++]=X+_;return new c({attributes:R,indices:D,primitiveType:v.TRIANGLES,boundingSphere:e.fromEllipsoid(F),offsetAttribute:i._offsetAttribute})}},F.getUnitEllipsoid=function(){return o(T)||(T=F.createGeometry(new F({radii:new a(1,1,1),vertexFormat:y.POSITION_ONLY}))),T},F});