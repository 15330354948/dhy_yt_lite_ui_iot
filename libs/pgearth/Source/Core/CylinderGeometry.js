define(["./arrayFill","./BoundingSphere","./Cartesian2","./Cartesian3","./ComponentDatatype","./CylinderGeometryLibrary","./defaultValue","./defined","./DeveloperError","./Geometry","./GeometryAttribute","./GeometryAttributes","./GeometryOffsetAttribute","./IndexDatatype","./Math","./PrimitiveType","./VertexFormat"],function(t,e,r,n,o,a,i,s,u,f,m,p,d,l,b,c,v){"use strict";var y=new r,h=new n,w=new n,g=new n,A=new n;function _(t){var e=(t=i(t,i.EMPTY_OBJECT)).length,r=t.topRadius,n=t.bottomRadius,o=i(t.vertexFormat,v.DEFAULT),a=i(t.slices,128);if(!s(e))throw new u("options.length must be defined.");if(!s(r))throw new u("options.topRadius must be defined.");if(!s(n))throw new u("options.bottomRadius must be defined.");if(a<3)throw new u("options.slices must be greater than or equal to 3.");if(s(t.offsetAttribute)&&t.offsetAttribute===d.TOP)throw new u("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=r,this._bottomRadius=n,this._vertexFormat=v.clone(o),this._slices=a,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}_.packedLength=v.packedLength+5,_.pack=function(t,e,r){if(!s(t))throw new u("value is required");if(!s(e))throw new u("array is required");return r=i(r,0),v.pack(t._vertexFormat,e,r),r+=v.packedLength,e[r++]=t._length,e[r++]=t._topRadius,e[r++]=t._bottomRadius,e[r++]=t._slices,e[r]=i(t._offsetAttribute,-1),e};var x,R=new v,F={vertexFormat:R,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};return _.unpack=function(t,e,r){if(!s(t))throw new u("array is required");e=i(e,0);var n=v.unpack(t,e,R);e+=v.packedLength;var o=t[e++],a=t[e++],f=t[e++],m=t[e++],p=t[e];return s(r)?(r._vertexFormat=v.clone(n,r._vertexFormat),r._length=o,r._topRadius=a,r._bottomRadius=f,r._slices=m,r._offsetAttribute=-1===p?void 0:p,r):(F.length=o,F.topRadius=a,F.bottomRadius=f,F.slices=m,F.offsetAttribute=-1===p?void 0:p,new _(F))},_.createGeometry=function(i){var u=i._length,v=i._topRadius,_=i._bottomRadius,x=i._vertexFormat,R=i._slices;if(!(u<=0||v<0||_<0||0===v&&0===_)){var F,O=R+R,T=R+O,L=O+O,P=a.computePositions(u,v,_,R,!0),D=x.st?new Float32Array(2*L):void 0,G=x.normal?new Float32Array(3*L):void 0,E=x.tangent?new Float32Array(3*L):void 0,k=x.bitangent?new Float32Array(3*L):void 0,z=x.normal||x.tangent||x.bitangent;if(z){var M=x.tangent||x.bitangent,N=0,C=0,I=0,U=Math.atan2(_-v,u),S=h;S.z=Math.sin(U);var q=Math.cos(U),B=g,Y=w;for(F=0;F<R;F++){var V=F/R*b.TWO_PI,Z=q*Math.cos(V),J=q*Math.sin(V);z&&(S.x=Z,S.y=J,M&&(B=n.normalize(n.cross(n.UNIT_Z,S,B),B)),x.normal&&(G[N++]=S.x,G[N++]=S.y,G[N++]=S.z,G[N++]=S.x,G[N++]=S.y,G[N++]=S.z),x.tangent&&(E[C++]=B.x,E[C++]=B.y,E[C++]=B.z,E[C++]=B.x,E[C++]=B.y,E[C++]=B.z),x.bitangent&&(Y=n.normalize(n.cross(S,B,Y),Y),k[I++]=Y.x,k[I++]=Y.y,k[I++]=Y.z,k[I++]=Y.x,k[I++]=Y.y,k[I++]=Y.z))}for(F=0;F<R;F++)x.normal&&(G[N++]=0,G[N++]=0,G[N++]=-1),x.tangent&&(E[C++]=1,E[C++]=0,E[C++]=0),x.bitangent&&(k[I++]=0,k[I++]=-1,k[I++]=0);for(F=0;F<R;F++)x.normal&&(G[N++]=0,G[N++]=0,G[N++]=1),x.tangent&&(E[C++]=1,E[C++]=0,E[C++]=0),x.bitangent&&(k[I++]=0,k[I++]=1,k[I++]=0)}var W=12*R-12,j=l.createTypedArray(L,W),H=0,K=0;for(F=0;F<R-1;F++)j[H++]=K,j[H++]=K+2,j[H++]=K+3,j[H++]=K,j[H++]=K+3,j[H++]=K+1,K+=2;for(j[H++]=O-2,j[H++]=0,j[H++]=1,j[H++]=O-2,j[H++]=1,j[H++]=O-1,F=1;F<R-1;F++)j[H++]=O+F+1,j[H++]=O+F,j[H++]=O;for(F=1;F<R-1;F++)j[H++]=T,j[H++]=T+F,j[H++]=T+F+1;var Q=0;if(x.st){var X=Math.max(v,_);for(F=0;F<L;F++){var $=n.fromArray(P,3*F,A);D[Q++]=($.x+X)/(2*X),D[Q++]=($.y+X)/(2*X)}}var tt=new p;x.position&&(tt.position=new m({componentDatatype:o.DOUBLE,componentsPerAttribute:3,values:P})),x.normal&&(tt.normal=new m({componentDatatype:o.FLOAT,componentsPerAttribute:3,values:G})),x.tangent&&(tt.tangent=new m({componentDatatype:o.FLOAT,componentsPerAttribute:3,values:E})),x.bitangent&&(tt.bitangent=new m({componentDatatype:o.FLOAT,componentsPerAttribute:3,values:k})),x.st&&(tt.st=new m({componentDatatype:o.FLOAT,componentsPerAttribute:2,values:D})),y.x=.5*u,y.y=Math.max(_,v);var et=new e(n.ZERO,r.magnitude(y));if(s(i._offsetAttribute)){u=P.length;var rt=new Uint8Array(u/3),nt=i._offsetAttribute===d.NONE?0:1;t(rt,nt),tt.applyOffset=new m({componentDatatype:o.UNSIGNED_BYTE,componentsPerAttribute:1,values:rt})}return new f({attributes:tt,indices:j,primitiveType:c.TRIANGLES,boundingSphere:et,offsetAttribute:i._offsetAttribute})}},_.getUnitCylinder=function(){return s(x)||(x=_.createGeometry(new _({topRadius:1,bottomRadius:1,length:1,vertexFormat:v.POSITION_ONLY}))),x},_});