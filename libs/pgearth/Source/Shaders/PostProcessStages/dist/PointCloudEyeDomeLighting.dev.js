"use strict";

define(function () {
  "use strict";

  return "#extension GL_EXT_frag_depth : enable\nuniform sampler2D u_pointCloud_colorGBuffer;\nuniform sampler2D u_pointCloud_depthGBuffer;\nuniform vec3 u_distancesAndEdlStrength;\nvarying vec2 v_textureCoordinates;\nvec2 neighborContribution(float log2Depth, vec2 padding)\n{\nfloat depthOrLogDepth = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, v_textureCoordinates + padding));\nif (depthOrLogDepth == 0.0) {\nreturn vec2(0.0);\n}\nvec4 eyeCoordinate = czm_windowToEyeCoordinates(v_textureCoordinates + padding, depthOrLogDepth);\nreturn vec2(max(0.0, log2Depth - log2(-eyeCoordinate.z / eyeCoordinate.w)), 1.0);\n}\nvoid main()\n{\nfloat depthOrLogDepth = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, v_textureCoordinates));\nvec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depthOrLogDepth);\neyeCoordinate /= eyeCoordinate.w;\nfloat log2Depth = log2(-eyeCoordinate.z);\nif (depthOrLogDepth == 0.0)\n{\ndiscard;\n}\nvec4 color = texture2D(u_pointCloud_colorGBuffer, v_textureCoordinates);\nfloat distX = u_distancesAndEdlStrength.x;\nfloat distY = u_distancesAndEdlStrength.y;\nvec2 responseAndCount = vec2(0.0);\nresponseAndCount += neighborContribution(log2Depth, vec2(0, distY));\nresponseAndCount += neighborContribution(log2Depth, vec2(distX, 0));\nresponseAndCount += neighborContribution(log2Depth, vec2(0, -distY));\nresponseAndCount += neighborContribution(log2Depth, vec2(-distX, 0));\nfloat response = responseAndCount.x / responseAndCount.y;\nfloat shade = exp(-response * 300.0 * u_distancesAndEdlStrength.z);\ncolor.rgb *= shade;\ngl_FragColor = vec4(color);\n#ifdef LOG_DEPTH\nczm_writeLogDepth(1.0 + (czm_projection * vec4(eyeCoordinate.xyz, 1.0)).w);\n#else\ngl_FragDepthEXT = czm_eyeToWindowCoordinates(vec4(eyeCoordinate.xyz, 1.0)).z;\n#endif\n}\n";
});