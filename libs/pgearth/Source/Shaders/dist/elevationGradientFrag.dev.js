"use strict";

define(function () {
  "use strict";

  return "precision mediump float;\nuniform sampler2D u_image;\nuniform sampler2D u_mask;\nuniform vec2 u_textureSize;\nuniform vec2 u_tileDimension;\nuniform float u_zFactor;\nuniform float u_zenith;\nuniform float u_azimuth;\nuniform float u_majorContour;\nuniform float u_minorContour;\nuniform float u_hillshadeAmount;\nuniform float u_gradientAmount;\nuniform float u_contourAmount;\nuniform float u_useSlope;\nuniform vec4 u_contourColor;\nuniform vec4 u_gradientColors[GRADIENT_STOP_COUNT];\nuniform float u_gradientValues[GRADIENT_STOP_COUNT];\nvarying vec2 v_texCoord;\nuniform vec2 u_tileElevationRange;\n#define M_PI 3.1415926535897932384626433832795\n#define CONTOUR_MAJOR_OPACITY 1.0\n#define CONTOUR_MINOR_OPACITY 0.3\nvec3 light = vec3(255., 231., 177.) / vec3(255.);\nvec3 shade = vec3(3., 152., 255.) / vec3(255.);\nvec2 cellsize = u_tileDimension / u_textureSize;\nfloat colourToElevation(vec4 col){\nfloat range = u_tileElevationRange.y - u_tileElevationRange.x;\nreturn mix(u_tileElevationRange.x, u_tileElevationRange.y, col.r) + range * col.g / 255.;\n}\nfloat getElevation(vec2 coord){\nvec4 col = texture2D(u_image, coord);\nreturn colourToElevation(col);\n}\nfloat calcSlope(float a, float b, float c, float d, float e, float f, float g, float h, float i) {\nfloat dzdx = ((c + 2.0 * f + i) - (a + 2.0 * d + g)) / (8.0 * cellsize.x);\nfloat dzdy = ((g + 2.0 * h + i) - (a + 2.0 * b + c)) / (8.0 * cellsize.y);\nreturn atan(sqrt(dzdx * dzdx + dzdy * dzdy)) * 180. / M_PI;\n}\nfloat calcHillshade(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nfloat dzdx = ((c + 2.0 * f + i) - (a + 2.0 * d + g)) / (8.0 * cellsize.x);\nfloat dzdy = ((g + 2.0 * h + i) - (a + 2.0 * b + c)) / (8.0 * cellsize.y);\nfloat slope = atan(u_zFactor * sqrt(dzdx * dzdx + dzdy * dzdy));\nfloat aspect = atan(dzdy, -dzdx);\nif(aspect < 0.0){\naspect = aspect +  2.0 * M_PI;\n}\nfloat hillshade = ((cos(u_zenith) * cos(slope)) + (sin(u_zenith) * sin(slope) * cos(u_azimuth - aspect)));\nreturn clamp(hillshade, 0., 1.);\n}\nfloat linstep(float edge0, float edge1, float x){\nreturn clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\nfloat detectEdge(float x, float a, float b){\nreturn float(x > min(a,b) && x < max(a,b));\n}\nfloat calcDistance(float x, float a, float b, float c, float d, float e){\nfloat s0 = (c - b) * 0.5;\nfloat s1 = (e - d) * 0.5;\nfloat s = (abs(s0) + abs(s1)) * 0.5;\nreturn abs((x-a) / s);\n}\nfloat calcContour(float minor, float major, float a, float b, float c, float d, float e, float f, float g, float h, float i){\nfloat x = floor(e * (1.0 / minor) + 0.5) * minor;\nfloat isMajor = float(mod(x, major) < 0.01);\nfloat isMinor = (1.0 - isMajor);\nfloat dist = calcDistance(x, e, d, f, b, h);\nfloat result = linstep(2.0, 0.5, dist);\nresult *= CONTOUR_MAJOR_OPACITY * isMajor + CONTOUR_MINOR_OPACITY * isMinor;\nreturn clamp(result, 0., 1.);\n}\nvec3 applyTint(float hillshade) {\nreturn mix(shade, light, hillshade) * hillshade * 1.2;\n}\nvec3 applyGamma(vec3 col){\nreturn clamp(pow(col, vec3(0.8)), vec3(0.), vec3(1.));\n}\nfloat rand(vec2 co){\nreturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec4 calcGradientColour(float e){\nif(e <= u_gradientValues[0]){\nreturn u_gradientColors[0];\n}\nfor(int i = 1; i < GRADIENT_STOP_COUNT; ++i){\nif(e <= u_gradientValues[i]){\nfloat a = (e - u_gradientValues[i-1]) / (u_gradientValues[i] - u_gradientValues[i-1]);\nreturn mix(u_gradientColors[i-1], u_gradientColors[i], a);\n}\n}\nreturn u_gradientColors[GRADIENT_STOP_COUNT-1];\n}\nvoid main() {\nvec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\nvec4 maskColour = texture2D(u_mask, v_texCoord);\nfloat maskValue = maskColour.a;\nfloat a = getElevation(v_texCoord + onePixel * vec2(-1.0, -1.0));\nfloat b = getElevation(v_texCoord + onePixel * vec2( 0.0, -1.0));\nfloat c = getElevation(v_texCoord + onePixel * vec2( 1.0, -1.0));\nfloat d = getElevation(v_texCoord + onePixel * vec2(-1.0,  0.0));\nfloat e = getElevation(v_texCoord + onePixel * vec2( 0.0,  0.0));\nfloat f = getElevation(v_texCoord + onePixel * vec2( 1.0,  0.0));\nfloat g = getElevation(v_texCoord + onePixel * vec2(-1.0,  1.0));\nfloat h = getElevation(v_texCoord + onePixel * vec2( 0.0,  1.0));\nfloat i = getElevation(v_texCoord + onePixel * vec2( 1.0,  1.0));\nfloat hillshade = mix(1., calcHillshade(a, b, c, d, e, f, g, h, i), u_hillshadeAmount);\nvec3 colourHillshade = applyTint(hillshade);\nfloat slope = calcSlope(a, b, c, d, e, f, g, h, i);\nvec4 gradientColor = calcGradientColour(u_useSlope > 0.5 ? slope : e);\nfloat contourAmount = gradientColor.a > CONTOUR_OPACITY_THRESHOLD ? u_contourAmount : 0.;\nfloat contour = contourAmount * calcContour(u_minorContour, u_majorContour, a, b, c, d, e, f, g, h, i);\nvec4 litColour = gradientColor * vec4(colourHillshade, 1.0) * u_gradientAmount;\nvec4 unmaskedColour = mix(litColour, u_contourColor, contour);\nvec4 clampedColour = clamp(unmaskedColour, vec4(0.0), vec4(unmaskedColour.a));\ngl_FragColor = mix(vec4(0.0, 0.0, 0.0, 0.0), clampedColour, maskValue);\n}\n";
});