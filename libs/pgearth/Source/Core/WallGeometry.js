define(["./BoundingSphere","./Cartesian3","./ComponentDatatype","./defaultValue","./defined","./DeveloperError","./Ellipsoid","./Geometry","./GeometryAttribute","./GeometryAttributes","./IndexDatatype","./Math","./PrimitiveType","./VertexFormat","./WallGeometryLibrary"],function(e,t,i,n,r,o,a,s,m,l,p,u,h,g,c){"use strict";var v=new t,y=new t,d=new t,f=new t,w=new t,A=new t,_=new t,x=new t;function H(e){var i=(e=n(e,n.EMPTY_OBJECT)).positions,s=e.maximumHeights,m=e.minimumHeights;if(!r(i))throw new o("options.positions is required.");if(r(s)&&s.length!==i.length)throw new o("options.positions and options.maximumHeights must have the same length.");if(r(m)&&m.length!==i.length)throw new o("options.positions and options.minimumHeights must have the same length.");var l=n(e.vertexFormat,g.DEFAULT),p=n(e.granularity,u.RADIANS_PER_DEGREE),h=n(e.ellipsoid,a.WGS84);this._positions=i,this._minimumHeights=m,this._maximumHeights=s,this._vertexFormat=g.clone(l),this._granularity=p,this._ellipsoid=a.clone(h),this._workerName="createWallGeometry";var c=1+i.length*t.packedLength+2;r(m)&&(c+=m.length),r(s)&&(c+=s.length),this.packedLength=c+a.packedLength+g.packedLength+1}H.pack=function(e,i,s){if(!r(e))throw new o("value is required");if(!r(i))throw new o("array is required");var m;s=n(s,0);var l=e._positions,p=l.length;for(i[s++]=p,m=0;m<p;++m,s+=t.packedLength)t.pack(l[m],i,s);var u=e._minimumHeights;if(p=r(u)?u.length:0,i[s++]=p,r(u))for(m=0;m<p;++m)i[s++]=u[m];var h=e._maximumHeights;if(p=r(h)?h.length:0,i[s++]=p,r(h))for(m=0;m<p;++m)i[s++]=h[m];return a.pack(e._ellipsoid,i,s),s+=a.packedLength,g.pack(e._vertexFormat,i,s),i[s+=g.packedLength]=e._granularity,i};var b=a.clone(a.UNIT_SPHERE),E=new g,F={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:b,vertexFormat:E,granularity:void 0};return H.unpack=function(e,i,s){if(!r(e))throw new o("array is required");var m;i=n(i,0);var l,p,u=e[i++],h=new Array(u);for(m=0;m<u;++m,i+=t.packedLength)h[m]=t.unpack(e,i);if((u=e[i++])>0)for(l=new Array(u),m=0;m<u;++m)l[m]=e[i++];if((u=e[i++])>0)for(p=new Array(u),m=0;m<u;++m)p[m]=e[i++];var c=a.unpack(e,i,b);i+=a.packedLength;var v=g.unpack(e,i,E),y=e[i+=g.packedLength];return r(s)?(s._positions=h,s._minimumHeights=l,s._maximumHeights=p,s._ellipsoid=a.clone(c,s._ellipsoid),s._vertexFormat=g.clone(v,s._vertexFormat),s._granularity=y,s):(F.positions=h,F.minimumHeights=l,F.maximumHeights=p,F.granularity=y,new H(F))},H.fromConstantHeights=function(e){var t,i,a=(e=n(e,n.EMPTY_OBJECT)).positions;if(!r(a))throw new o("options.positions is required.");var s=e.minimumHeight,m=e.maximumHeight,l=r(s),p=r(m);if(l||p){var u=a.length;t=l?new Array(u):void 0,i=p?new Array(u):void 0;for(var h=0;h<u;++h)l&&(t[h]=s),p&&(i[h]=m)}return new H({positions:a,maximumHeights:i,minimumHeights:t,ellipsoid:e.ellipsoid,vertexFormat:e.vertexFormat})},H.createGeometry=function(n){var o=n._positions,a=n._minimumHeights,g=n._maximumHeights,H=n._vertexFormat,b=n._granularity,E=n._ellipsoid,F=c.computePositions(E,o,g,a,b,!0);if(r(F)){var L,k=F.bottomPositions,T=F.topPositions,P=F.numCorners,D=T.length,z=2*D,G=H.position?new Float64Array(z):void 0,O=H.normal?new Float32Array(z):void 0,S=H.tangent?new Float32Array(z):void 0,q=H.bitangent?new Float32Array(z):void 0,C=H.st?new Float32Array(z/3*2):void 0,I=0,N=0,R=0,B=0,M=0,U=x,V=_,W=A,J=!0,Y=0,Z=1/((D/=3)-o.length+1);for(L=0;L<D;++L){var j=3*L,K=t.fromArray(T,j,v),Q=t.fromArray(k,j,y);if(H.position&&(G[I++]=Q.x,G[I++]=Q.y,G[I++]=Q.z,G[I++]=K.x,G[I++]=K.y,G[I++]=K.z),H.st&&(C[M++]=Y,C[M++]=0,C[M++]=Y,C[M++]=1),H.normal||H.tangent||H.bitangent){var X,$=t.clone(t.ZERO,w),ee=E.scaleToGeodeticSurface(t.fromArray(T,j,y),y);if(L+1<D&&(X=E.scaleToGeodeticSurface(t.fromArray(T,j+3,d),d),$=t.fromArray(T,j+3,w)),J){var te=t.subtract($,K,f),ie=t.subtract(ee,K,v);U=t.normalize(t.cross(ie,te,U),U),J=!1}t.equalsEpsilon(X,ee,u.EPSILON10)?J=!0:(Y+=Z,H.tangent&&(V=t.normalize(t.subtract(X,ee,V),V)),H.bitangent&&(W=t.normalize(t.cross(U,V,W),W))),H.normal&&(O[N++]=U.x,O[N++]=U.y,O[N++]=U.z,O[N++]=U.x,O[N++]=U.y,O[N++]=U.z),H.tangent&&(S[B++]=V.x,S[B++]=V.y,S[B++]=V.z,S[B++]=V.x,S[B++]=V.y,S[B++]=V.z),H.bitangent&&(q[R++]=W.x,q[R++]=W.y,q[R++]=W.z,q[R++]=W.x,q[R++]=W.y,q[R++]=W.z)}}var ne=new l;H.position&&(ne.position=new m({componentDatatype:i.DOUBLE,componentsPerAttribute:3,values:G})),H.normal&&(ne.normal=new m({componentDatatype:i.FLOAT,componentsPerAttribute:3,values:O})),H.tangent&&(ne.tangent=new m({componentDatatype:i.FLOAT,componentsPerAttribute:3,values:S})),H.bitangent&&(ne.bitangent=new m({componentDatatype:i.FLOAT,componentsPerAttribute:3,values:q})),H.st&&(ne.st=new m({componentDatatype:i.FLOAT,componentsPerAttribute:2,values:C}));var re=z/3;z-=6*(P+1);var oe=p.createTypedArray(re,z),ae=0;for(L=0;L<re-2;L+=2){var se=L,me=L+2,le=t.fromArray(G,3*se,v),pe=t.fromArray(G,3*me,y);if(!t.equalsEpsilon(le,pe,u.EPSILON10)){var ue=L+1,he=L+3;oe[ae++]=ue,oe[ae++]=se,oe[ae++]=he,oe[ae++]=he,oe[ae++]=se,oe[ae++]=me}}return new s({attributes:ne,indices:oe,primitiveType:h.TRIANGLES,boundingSphere:new e.fromVertices(G)})}},H});