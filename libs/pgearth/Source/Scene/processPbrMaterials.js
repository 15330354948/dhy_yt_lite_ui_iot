define(["./ModelUtility","../Core/defined","../Core/defaultValue","../Core/WebGLConstants","../Core/webGLConstantToGlslType","../ThirdParty/GltfPipeline/addToArray","../ThirdParty/GltfPipeline/ForEach","../ThirdParty/GltfPipeline/hasExtension","../ThirdParty/GltfPipeline/numberOfComponentsForType"],function(e,n,o,t,r,i,a,s,l){"use strict";function c(e,o,r,i,a){var s;if(n(r[o+"Offset"])){var l=r[o].index,c=e.samplers[e.textures[l].sampler],u=c.wrapS===t.REPEAT?"true":"false",f=c.wrapT===t.REPEAT?"true":"false";s=o+"Coord",a.fragmentShaderMain+="    vec2 "+s+" = computeTexCoord("+i+", "+o+"Offset, "+o+"Rotation, "+o+"Scale, "+u+", "+f+");\n"}else s=i;return s}var u=[0,0],f=[0],d=[1,1];function _(e,t,r){if(-1!==e.indexOf("Texture")&&n(t.extensions)&&n(t.extensions.KHR_texture_transform)){var i="u_"+e,a=t.extensions.KHR_texture_transform;r[i+"Offset"]=o(a.offset,u),r[i+"Rotation"]=o(a.rotation,f),r[i+"Scale"]=o(a.scale,d),n(t.texCoord)&&n(a.texCoord)&&(r[i].texCoord=a.texCoord)}}function v(e){if(-1!==e.indexOf("Offset"))return t.FLOAT_VEC2;if(-1!==e.indexOf("Rotation"))return t.FLOAT;if(-1!==e.indexOf("Scale"))return t.FLOAT_VEC2;if(-1!==e.indexOf("Texture"))return t.SAMPLER_2D;switch(e){case"u_baseColorFactor":return t.FLOAT_VEC4;case"u_metallicFactor":case"u_roughnessFactor":return t.FLOAT;case"u_emissiveFactor":return t.FLOAT_VEC3;case"u_diffuseFactor":return t.FLOAT_VEC4;case"u_specularFactor":return t.FLOAT_VEC3;case"u_glossinessFactor":return t.FLOAT}}return function(u,f){if(f=o(f,{}),s(u,"KHR_techniques_webgl"))return u;if(!n(u.materials)||0===u.materials.length)return u;n(u.extensions)||(u.extensions={}),n(u.extensionsUsed)||(u.extensionsUsed=[]),n(u.extensionsRequired)||(u.extensionsRequired=[]),u.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},u.extensionsUsed.push("KHR_techniques_webgl"),u.extensionsRequired.push("KHR_techniques_webgl");var d=e.splitIncompatibleMaterials(u);return a.material(u,function(m,p){var g={},h=function(u,f,d,m,p,g){var h,x,C,b=o(g.addBatchIdToGeneratedShaders,!1),T=u.extensions.KHR_techniques_webgl,L=T.techniques,R=T.shaders,S=T.programs,F=function(e){return n(e.extensions)&&n(e.extensions.KHR_materials_pbrSpecularGlossiness)}(f),I=f.pbrMetallicRoughness;if(n(I)&&!F)for(x in I)I.hasOwnProperty(x)&&(C=I[x],m[h="u_"+x]=C,_(x,C,m));if(F){var E=f.extensions.KHR_materials_pbrSpecularGlossiness;for(x in E)E.hasOwnProperty(x)&&(C=E[x],m[h="u_"+x]=C,_(x,C,m))}for(var N in f)f.hasOwnProperty(N)&&(N.indexOf("Texture")>=0||N.indexOf("Factor")>=0)&&(C=f[N],m[h="u_"+N]=C,_(N,C,m));var z,y="precision highp float;\n",O="precision highp float;\n";n(u.skins)&&(z=u.skins[0]);var A,M,H=n(z)?z.joints:[],D=H.length,w=p[d],G=!1,P=!1,V=!1,B=!1,U=!1,W=!1,k=!1;n(w)&&(A=w.skinning,G=A.skinned&&H.length>0,P=w.hasVertexColors,V=w.hasMorphTargets,B=w.hasNormals,U=w.hasTangents,W=w.hasTexCoords),V&&a.mesh(u,function(e){a.meshPrimitive(e,function(e){if(e.material===d){var o=e.targets;n(o)&&(M=o)}})});var q={u_modelViewMatrix:{semantic:s(u,"PGEARTH_RTC")?"PGEARTH_RTC_MODELVIEW":"MODELVIEW",type:t.FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:t.FLOAT_MAT4}};n(f.extensions)&&n(f.extensions.KHR_materials_unlit)&&(k=!0,B=!1,U=!1),B&&(q.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:t.FLOAT_MAT3}),G&&(q.u_jointMatrix={count:D,semantic:"JOINTMATRIX",type:t.FLOAT_MAT4}),V&&(q.u_morphWeights={count:M.length,semantic:"MORPHWEIGHTS",type:t.FLOAT});var K=f.alphaMode;for(h in n(K)&&"MASK"===K&&(q.u_alphaCutoff={semantic:"ALPHACUTOFF",type:t.FLOAT}),m)m.hasOwnProperty(h)&&(q[h]={type:v(h)});var j=o(q.u_baseColorTexture,q.u_baseColorFactor);for(h in n(j)&&(j.semantic="_3DTILESDIFFUSE"),q)if(q.hasOwnProperty(h)){var Z=q[h],X=n(Z.count)?"["+Z.count+"]":"";Z.type!==t.FLOAT_MAT3&&Z.type!==t.FLOAT_MAT4&&"u_morphWeights"!==h||Z.useInFragment?(O+="uniform "+r(Z.type)+" "+h+X+";\n",delete Z.useInFragment):y+="uniform "+r(Z.type)+" "+h+X+";\n"}var J="";if(G){var Q,Y,$=l(A.type),ee=!1;if(0===A.type.indexOf("MAT")&&(ee=!0,$=Math.sqrt($)),ee)for(Q=0;Q<$;Q++)for(Y=0;Y<$;Y++)J+=0===Q&&0===Y?"    mat4 skinMatrix = ":"    skinMatrix += ",J+="a_weight["+Q+"]["+Y+"] * u_jointMatrix[int(a_joint["+Q+"]["+Y+"])];\n";else for(Q=0;Q<$;Q++)J+=0===Q?"    mat4 skinMatrix = ":"    skinMatrix += ",J+="a_weight["+Q+"] * u_jointMatrix[int(a_joint["+Q+"])];\n"}var ne={a_position:{semantic:"POSITION"}};if(y+="attribute vec3 a_position;\n",B&&(y+="varying vec3 v_positionEC;\n"),J+="    vec3 weightedPosition = a_position;\n",B&&(J+="    vec3 weightedNormal = a_normal;\n"),U&&(J+="    vec4 weightedTangent = a_tangent;\n"),V)for(var oe=0;oe<M.length;oe++){var te=M[oe];for(var re in te)if(te.hasOwnProperty(re)&&"extras"!==re){var ie="a_"+re+"_"+oe;ne[ie]={semantic:re+"_"+oe},y+="attribute vec3 "+ie+";\n","POSITION"===re?J+="    weightedPosition += u_morphWeights["+oe+"] * "+ie+";\n":"NORMAL"===re?J+="    weightedNormal += u_morphWeights["+oe+"] * "+ie+";\n":U&&"TANGENT"===re&&(J+="    weightedTangent.xyz += u_morphWeights["+oe+"] * "+ie+";\n")}}J+=G?"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\n":"    vec4 position = vec4(weightedPosition, 1.0);\n",J+="    position = u_modelViewMatrix * position;\n",B&&(J+="    v_positionEC = position.xyz;\n"),J+="    gl_Position = u_projectionMatrix * position;\n",B&&(ne.a_normal={semantic:"NORMAL"},y+="attribute vec3 a_normal;\n",y+="varying vec3 v_normal;\n",J+=G?"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\n":"    v_normal = u_normalMatrix * weightedNormal;\n",O+="varying vec3 v_normal;\n",O+="varying vec3 v_positionEC;\n"),U&&(ne.a_tangent={semantic:"TANGENT"},y+="attribute vec4 a_tangent;\n",y+="varying vec4 v_tangent;\n",J+="    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\n",J+="    v_tangent.w = weightedTangent.w;\n",O+="varying vec4 v_tangent;\n");var ae,se,le,ce,ue,fe,de,_e,ve="";if(W){ne.a_texcoord_0={semantic:"TEXCOORD_0"},y+="attribute vec2 a_texcoord_0;\n",y+="varying vec2 "+(ae="v_texcoord_0")+";\n",J+="    "+ae+" = a_texcoord_0;\n",O+="varying vec2 "+ae+";\n";var me={fragmentShaderMain:ve};se=c(u,"u_normalTexture",m,ae,me),le=c(u,"u_baseColorTexture",m,ae,me),ce=c(u,"u_specularGlossinessTexture",m,ae,me),ue=c(u,"u_diffuseTexture",m,ae,me),fe=c(u,"u_metallicRoughnessTexture",m,ae,me),de=c(u,"u_occlusionTexture",m,ae,me),_e=c(u,"u_emmissiveTexture",m,ae,me),ve=me.fragmentShaderMain}if(G){var pe=e.getShaderVariable(A.type);ne.a_joint={semantic:"JOINTS_0"},ne.a_weight={semantic:"WEIGHTS_0"},y+="attribute "+pe+" a_joint;\n",y+="attribute "+pe+" a_weight;\n"}P&&(ne.a_vertexColor={semantic:"COLOR_0"},y+="attribute vec4 a_vertexColor;\n",y+="varying vec4 v_vertexColor;\n",J+="  v_vertexColor = a_vertexColor;\n",O+="varying vec4 v_vertexColor;\n"),b&&(ne.a_batchId={semantic:"_BATCHID"},y+="attribute float a_batchId;\n"),y+="void main(void) \n{\n",y+=J,y+="}\n",B&&(O+="const float M_PI = 3.141592653589793;\n",O+="vec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor / M_PI;\n}\n\n",O+="vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n",O+="vec3 fresnelSchlick(float metalness, float VdotH) \n{\n    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n}\n\n",O+="float smithVisibilityG1(float NdotV, float roughness) \n{\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\n",O+="float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \n{\n    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\n\n",O+="float GGX(float roughness, float NdotH) \n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (M_PI * f * f);\n}\n\n"),O+="vec3 SRGBtoLINEAR3(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\n",O+="vec4 SRGBtoLINEAR4(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\n",O+="vec3 LINEARtoSRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\n",O+="vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale, bool repeatS, bool repeatT) \n{\n    rotation = -rotation; \n    mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \n       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \n        offset.x, offset.y, 1.0); \n    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \n    transformedTexCoords.x = repeatS ? fract(transformedTexCoords.x) : clamp(transformedTexCoords.x, 0.0, 1.0); \n    transformedTexCoords.y = repeatT ? fract(transformedTexCoords.y) : clamp(transformedTexCoords.y, 0.0, 1.0); \n    return transformedTexCoords; \n}\n\n",O+="#ifdef USE_IBL_LIGHTING \n",O+="uniform vec2 gltf_iblFactor; \n",O+="#endif \n",O+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",O+="uniform vec3 gltf_lightColor; \n",O+="#endif \n",O+="void main(void) \n{\n",O+=ve,B&&(O+="    vec3 ng = normalize(v_normal);\n",O+="    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\n",n(m.u_normalTexture)?U?(O+="    vec3 t = normalize(v_tangent.xyz);\n",O+="    vec3 b = normalize(cross(ng, t) * v_tangent.w);\n",O+="    mat3 tbn = mat3(t, b, ng);\n",O+="    vec3 n = texture2D(u_normalTexture, "+se+").rgb;\n",O+="    n = normalize(tbn * (2.0 * n - 1.0));\n"):(O="#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"+O,O+="#ifdef GL_OES_standard_derivatives\n",O+="    vec3 pos_dx = dFdx(v_positionEC);\n",O+="    vec3 pos_dy = dFdy(v_positionEC);\n",O+="    vec3 tex_dx = dFdx(vec3("+se+",0.0));\n",O+="    vec3 tex_dy = dFdy(vec3("+se+",0.0));\n",O+="    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n",O+="    t = normalize(t - ng * dot(ng, t));\n",O+="    vec3 b = normalize(cross(ng, t));\n",O+="    mat3 tbn = mat3(t, b, ng);\n",O+="    vec3 n = texture2D(u_normalTexture, "+se+").rgb;\n",O+="    n = normalize(tbn * (2.0 * n - 1.0));\n",O+="#else\n",O+="    vec3 n = ng;\n",O+="#endif\n"):O+="    vec3 n = ng;\n",f.doubleSided&&(O+="    if (!gl_FrontFacing)\n",O+="    {\n",O+="        n = -n;\n",O+="    }\n")),n(m.u_baseColorTexture)?(O+="    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, "+le+"));\n",n(m.u_baseColorFactor)&&(O+="    baseColorWithAlpha *= u_baseColorFactor;\n")):n(m.u_baseColorFactor)?O+="    vec4 baseColorWithAlpha = u_baseColorFactor;\n":O+="    vec4 baseColorWithAlpha = vec4(1.0);\n",P&&(O+="    baseColorWithAlpha *= v_vertexColor;\n"),O+="    vec3 baseColor = baseColorWithAlpha.rgb;\n",B?(F?(n(m.u_specularGlossinessTexture)?(O+="    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, "+ce+"));\n",O+="    vec3 specular = specularGlossiness.rgb;\n",O+="    float glossiness = specularGlossiness.a;\n",n(m.u_specularFactor)&&(O+="    specular *= u_specularFactor;\n"),n(m.u_glossinessFactor)&&(O+="    glossiness *= u_glossinessFactor;\n")):(n(m.u_specularFactor)?O+="    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\n":O+="    vec3 specular = vec3(1.0);\n",n(m.u_glossinessFactor)?O+="    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\n":O+="    float glossiness = 1.0;\n"),n(m.u_diffuseTexture)?(O+="    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, "+ue+"));\n",n(m.u_diffuseFactor)&&(O+="    diffuse *= u_diffuseFactor;\n")):n(m.u_diffuseFactor)?O+="    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\n":O+="    vec4 diffuse = vec4(1.0);\n"):n(m.u_metallicRoughnessTexture)?(O+="    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, "+fe+").rgb;\n",O+="    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\n",O+="    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\n",n(m.u_metallicFactor)&&(O+="    metalness *= u_metallicFactor;\n"),n(m.u_roughnessFactor)&&(O+="    roughness *= u_roughnessFactor;\n")):(n(m.u_metallicFactor)?O+="    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n":O+="    float metalness = 1.0;\n",n(m.u_roughnessFactor)?O+="    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n":O+="    float roughness = 1.0;\n"),O+="    vec3 v = -normalize(v_positionEC);\n",O+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",O+="    vec3 lightColor = vec3(1.5, 1.4, 1.2);\n",O+="#else \n",O+="    vec3 lightColor = gltf_lightColor;\n",O+="#endif \n",O+="    vec3 l = normalize(czm_sunDirectionEC);\n",O+="    vec3 h = normalize(v + l);\n",O+="    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n",O+="    float NdotV = abs(dot(n, v)) + 0.001;\n",O+="    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n",O+="    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n",O+="    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n",O+="    vec3 f0 = vec3(0.04);\n",F?(O+="    float roughness = 1.0 - glossiness;\n",O+="    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\n",O+="    vec3 specularColor = specular;\n"):(O+="    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n",O+="    vec3 specularColor = mix(f0, baseColor, metalness);\n"),O+="    float alpha = roughness * roughness;\n",O+="    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n",O+="    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n",O+="    vec3 r0 = specularColor.rgb;\n",O+="    vec3 F = fresnelSchlick2(r0, r90, VdotH);\n",O+="    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n",O+="    float D = GGX(alpha, NdotH);\n",O+="    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n",O+="    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n",O+="    vec3 color = NdotL * lightColor * (diffuseContribution + specularContribution);\n",O+="#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \n",O+="    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n",O+="    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n",O+="    float vertexRadius = length(positionWC);\n",O+="    float horizonDotNadir = 1.0 - min(1.0, ellipsoid.radii.x / vertexRadius);\n",O+="    float reflectionDotNadir = dot(r, normalize(positionWC));\n",O+="    r.x = -r.x;\n",O+="    r = -normalize(czm_temeToPseudoFixed * r);\n",O+="    r.x = -r.x;\n",O+="    float inverseRoughness = 1.04 - roughness;\n",O+="    inverseRoughness *= inverseRoughness;\n",O+="    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n",O+="    float atmosphereHeight = 0.05;\n",O+="    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n",O+="    float blendRegionOffset = roughness * -1.0;\n",O+="    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n",O+="    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n",O+="    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n",O+="    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n",O+="    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n",O+="    vec3 nadirColor = belowHorizonColor * 0.5;\n",O+="    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n",O+="    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n",O+="    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n",O+="    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n",O+="    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n",O+="    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n",O+="    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n",O+="    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n",O+="    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n",O+="    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n",O+="    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n",O+="#ifdef USE_SUN_LUMINANCE \n",O+="    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\n",O+="    float S = acos(LdotZenith);\n",O+="    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n",O+="    float gamma = acos(NdotL);\n",O+="    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n",O+="    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n",O+="    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\n",O+="#endif \n",O+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;\n",O+="    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\n",O+="#ifdef USE_SUN_LUMINANCE \n",O+="    color += IBLColor * luminance;\n",O+="#else \n",O+="    color += IBLColor; \n",O+="#endif \n",O+="#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \n",O+="    mat3 fixedToENU = mat3(gltf_clippingPlanesMatrix[0][0], gltf_clippingPlanesMatrix[1][0], gltf_clippingPlanesMatrix[2][0], \n",O+="                           gltf_clippingPlanesMatrix[0][1], gltf_clippingPlanesMatrix[1][1], gltf_clippingPlanesMatrix[2][1], \n",O+="                           gltf_clippingPlanesMatrix[0][2], gltf_clippingPlanesMatrix[1][2], gltf_clippingPlanesMatrix[2][2]); \n",O+="    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \n",O+="    vec3 cubeDir = normalize(yUpToZUp * fixedToENU * normalize(reflect(-v, n))); \n",O+="#ifdef DIFFUSE_IBL \n",O+="#ifdef CUSTOM_SPHERICAL_HARMONICS \n",O+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \n",O+="#else \n",O+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \n",O+="#endif \n",O+="#else \n",O+="    vec3 diffuseIrradiance = vec3(0.0); \n",O+="#endif \n",O+="#ifdef SPECULAR_IBL \n",O+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",O+="#ifdef CUSTOM_SPECULAR_IBL \n",O+="    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\n",O+="#else \n",O+="    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n",O+="#endif \n",O+="    specularIBL *= F * brdfLut.x + brdfLut.y;\n",O+="#else \n",O+="    vec3 specularIBL = vec3(0.0); \n",O+="#endif \n",O+="    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\n",O+="#endif \n"):O+="    vec3 color = baseColor;\n",k||(n(m.u_occlusionTexture)&&(O+="    color *= texture2D(u_occlusionTexture, "+de+").r;\n"),n(m.u_emissiveTexture)?(O+="    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, "+_e+").rgb);\n",n(m.u_emissiveFactor)&&(O+="    emissive *= u_emissiveFactor;\n"),O+="    color += emissive;\n"):n(m.u_emissiveFactor)&&(O+="    color += u_emissiveFactor;\n")),O+="    color = LINEARtoSRGB(color);\n",n(K)?"MASK"===K?(O+="    if (baseColorWithAlpha.a < u_alphaCutoff) {\n",O+="        discard;\n",O+="    }\n",O+="    gl_FragColor = vec4(color, 1.0);\n"):O+="BLEND"===K?"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\n":"    gl_FragColor = vec4(color, 1.0);\n":O+="    gl_FragColor = vec4(color, 1.0);\n",O+="}\n";var ge=i(R,{type:t.VERTEX_SHADER,extras:{_pipeline:{source:y,extension:".glsl"}}}),he=i(R,{type:t.FRAGMENT_SHADER,extras:{_pipeline:{source:O,extension:".glsl"}}}),xe=i(S,{fragmentShader:he,vertexShader:ge});return i(L,{attributes:ne,program:xe,uniforms:q})}(u,m,p,g,d,f);n(m.extensions)||(m.extensions={}),m.extensions.KHR_techniques_webgl={values:g,technique:h}}),e.ensureSemanticExistence(u),u}});