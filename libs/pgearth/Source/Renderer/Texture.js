define(["../Core/Cartesian2","../Core/Check","../Core/createGuid","../Core/defaultValue","../Core/defined","../Core/defineProperties","../Core/destroyObject","../Core/DeveloperError","../Core/Math","../Core/PixelFormat","../Core/WebGLConstants","./ContextLimits","./MipmapHint","./PixelDatatype","./Sampler","./TextureMagnificationFilter","./TextureMinificationFilter"],function(e,t,i,r,a,o,n,s,h,f,p,u,_,l,m,x,T){"use strict";function E(o){o=r(o,r.EMPTY_OBJECT),t.defined("options.context",o.context);var n=o.context,h=o.width,_=o.height,x=o.source;a(x)&&(a(h)||(h=r(x.videoWidth,x.width)),a(_)||(_=r(x.videoHeight,x.height)));var T=r(o.pixelFormat,f.RGBA),E=r(o.pixelDatatype,l.UNSIGNED_BYTE),c=T,w=f.isCompressedFormat(c);if(n.webgl2)if(T===f.DEPTH_STENCIL?c=p.DEPTH24_STENCIL8:T===f.DEPTH_COMPONENT&&(E===l.UNSIGNED_SHORT?c=p.DEPTH_COMPONENT16:E===l.UNSIGNED_INT&&(c=p.DEPTH_COMPONENT24)),E===l.FLOAT)switch(T){case f.RGBA:c=p.RGBA32F;break;case f.RGB:c=p.RGB32F;break;case f.RG:c=p.RG32F;break;case f.R:c=p.R32F}else if(E===l.HALF_FLOAT)switch(T){case f.RGBA:c=p.RGBA16F;break;case f.RGB:c=p.RGB16F;break;case f.RG:c=p.RG16F;break;case f.R:c=p.R16F}if(!a(h)||!a(_))throw new s("options requires a source field to create an initialized texture or width and height fields to create a blank texture.");if(t.typeOf.number.greaterThan("width",h,0),h>u.maximumTextureSize)throw new s("Width must be less than or equal to the maximum texture size ("+u.maximumTextureSize+").  Check maximumTextureSize.");if(t.typeOf.number.greaterThan("height",_,0),_>u.maximumTextureSize)throw new s("Height must be less than or equal to the maximum texture size ("+u.maximumTextureSize+").  Check maximumTextureSize.");if(!f.validate(T))throw new s("Invalid options.pixelFormat.");if(!w&&!l.validate(E))throw new s("Invalid options.pixelDatatype.");if(T===f.DEPTH_COMPONENT&&E!==l.UNSIGNED_SHORT&&E!==l.UNSIGNED_INT)throw new s("When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.");if(T===f.DEPTH_STENCIL&&E!==l.UNSIGNED_INT_24_8)throw new s("When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8.");if(E===l.FLOAT&&!n.floatingPointTexture)throw new s("When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.");if(E===l.HALF_FLOAT&&!n.halfFloatingPointTexture)throw new s("When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture.");if(f.isDepthFormat(T)){if(a(x))throw new s("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.");if(!n.depthTexture)throw new s("When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.")}if(w){if(!a(x)||!a(x.arrayBufferView))throw new s("When options.pixelFormat is compressed, options.source.arrayBufferView must be defined.");if(f.isDXTFormat(c)&&!n.s3tc)throw new s("When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_texture_compression_s3tc extension. Check context.s3tc.");if(f.isPVRTCFormat(c)&&!n.pvrtc)throw new s("When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_texture_compression_pvrtc extension. Check context.pvrtc.");if(f.isETC1Format(c)&&!n.etc1)throw new s("When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_texture_compression_etc1 extension. Check context.etc1.");if(f.compressedTextureSizeInBytes(c,h,_)!==x.arrayBufferView.byteLength)throw new s("The byte length of the array buffer is invalid for the compressed texture with the given width and height.")}var d=o.preMultiplyAlpha||T===f.RGB||T===f.LUMINANCE,P=r(o.flipY,!0),F=!0,L=n._gl,g=L.TEXTURE_2D,A=L.createTexture();L.activeTexture(L.TEXTURE0),L.bindTexture(g,A);var N,O=4;if(a(x)&&a(x.arrayBufferView)&&!w&&(O=f.alignmentInBytes(T,E,h)),L.pixelStorei(L.UNPACK_ALIGNMENT,O),a(x))if(a(x.arrayBufferView)){L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL,!1);var C=x.arrayBufferView;w?L.compressedTexImage2D(g,0,c,h,_,0,C):(P&&(C=f.flipY(C,T,E,h,_)),L.texImage2D(g,0,c,h,_,0,T,E,C))}else a(x.framebuffer)?(L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL,!1),x.framebuffer!==n.defaultFramebuffer&&x.framebuffer._bind(),L.copyTexImage2D(g,0,c,x.xOffset,x.yOffset,h,_,0),x.framebuffer!==n.defaultFramebuffer&&x.framebuffer._unBind()):(L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL,d),L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL,P),L.texImage2D(g,0,c,T,E,x));else L.texImage2D(g,0,c,h,_,0,T,E,null),F=!1;L.bindTexture(g,null),N=w?f.compressedTextureSizeInBytes(T,h,_):f.textureSizeInBytes(T,E,h,_),this._id=i(),this._context=n,this._textureFilterAnisotropic=n._textureFilterAnisotropic,this._textureTarget=g,this._texture=A,this._pixelFormat=T,this._pixelDatatype=E,this._width=h,this._height=_,this._dimensions=new e(h,_),this._hasMipmap=!1,this._sizeInBytes=N,this._preMultiplyAlpha=d,this._flipY=P,this._initialized=F,this._sampler=void 0,this.sampler=a(o.sampler)?o.sampler:new m}return E.create=function(e){return new E(e)},E.fromFramebuffer=function(e){e=r(e,r.EMPTY_OBJECT),t.defined("options.context",e.context);var i=e.context,o=i._gl,n=r(e.pixelFormat,f.RGB),h=r(e.framebufferXOffset,0),p=r(e.framebufferYOffset,0),u=r(e.width,o.drawingBufferWidth),_=r(e.height,o.drawingBufferHeight),l=e.framebuffer;if(!f.validate(n))throw new s("Invalid pixelFormat.");if(f.isDepthFormat(n)||f.isCompressedFormat(n))throw new s("pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.");if(t.defined("options.context",e.context),t.typeOf.number.greaterThanOrEquals("framebufferXOffset",h,0),t.typeOf.number.greaterThanOrEquals("framebufferYOffset",p,0),h+u>o.drawingBufferWidth)throw new s("framebufferXOffset + width must be less than or equal to drawingBufferWidth");if(p+_>o.drawingBufferHeight)throw new s("framebufferYOffset + height must be less than or equal to drawingBufferHeight.");return new E({context:i,width:u,height:_,pixelFormat:n,source:{framebuffer:a(l)?l:i.defaultFramebuffer,xOffset:h,yOffset:p,width:u,height:_}})},o(E.prototype,{id:{get:function(){return this._id}},sampler:{get:function(){return this._sampler},set:function(e){var t=e.minificationFilter,i=e.magnificationFilter,r=t===T.NEAREST_MIPMAP_NEAREST||t===T.NEAREST_MIPMAP_LINEAR||t===T.LINEAR_MIPMAP_NEAREST||t===T.LINEAR_MIPMAP_LINEAR,o=this._context,n=this._pixelDatatype;(n===l.FLOAT&&!o.textureFloatLinear||n===l.HALF_FLOAT&&!o.textureHalfFloatLinear)&&(t=r?T.NEAREST_MIPMAP_NEAREST:T.NEAREST,i=x.NEAREST);var s=o._gl,h=this._textureTarget;s.activeTexture(s.TEXTURE0),s.bindTexture(h,this._texture),s.texParameteri(h,s.TEXTURE_MIN_FILTER,t),s.texParameteri(h,s.TEXTURE_MAG_FILTER,i),s.texParameteri(h,s.TEXTURE_WRAP_S,e.wrapS),s.texParameteri(h,s.TEXTURE_WRAP_T,e.wrapT),a(this._textureFilterAnisotropic)&&s.texParameteri(h,this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,e.maximumAnisotropy),s.bindTexture(h,null),this._sampler=e}},pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},dimensions:{get:function(){return this._dimensions}},preMultiplyAlpha:{get:function(){return this._preMultiplyAlpha}},flipY:{get:function(){return this._flipY}},width:{get:function(){return this._width}},height:{get:function(){return this._height}},sizeInBytes:{get:function(){return this._hasMipmap?Math.floor(4*this._sizeInBytes/3):this._sizeInBytes}},_target:{get:function(){return this._textureTarget}}}),E.prototype.copyFrom=function(e,i,o){if(i=r(i,0),o=r(o,0),t.defined("source",e),f.isDepthFormat(this._pixelFormat))throw new s("Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");if(f.isCompressedFormat(this._pixelFormat))throw new s("Cannot call copyFrom with a compressed texture pixel format.");t.typeOf.number.greaterThanOrEquals("xOffset",i,0),t.typeOf.number.greaterThanOrEquals("yOffset",o,0),t.typeOf.number.lessThanOrEquals("xOffset + source.width",i+e.width,this._width),t.typeOf.number.lessThanOrEquals("yOffset + source.height",o+e.height,this._height);var n=this._context._gl,h=this._textureTarget;n.activeTexture(n.TEXTURE0),n.bindTexture(h,this._texture);var p=e.width,u=e.height,_=e.arrayBufferView,l=this._width,m=this._height,x=this._pixelFormat,T=this._pixelDatatype,E=this._preMultiplyAlpha,c=this._flipY,w=4;a(_)&&(w=f.alignmentInBytes(x,T,p)),n.pixelStorei(n.UNPACK_ALIGNMENT,w);var d=!1;if(!this._initialized){if(0===i&&0===o&&p===l&&u===m)a(_)?(n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1),c&&(_=f.flipY(_,x,T,l,m)),n.texImage2D(h,0,x,l,m,0,x,T,_)):(n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,E),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,c),n.texImage2D(h,0,x,x,T,e)),d=!0;else{n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1);var P=f.createTypedArray(x,T,l,m);n.texImage2D(h,0,x,l,m,0,x,T,P)}this._initialized=!0}d||(a(_)?(n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1),c&&(_=f.flipY(_,x,T,p,u)),n.texSubImage2D(h,0,i,o,p,u,x,T,_)):(n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,E),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,c),n.texSubImage2D(h,0,i,o,x,T,e))),n.bindTexture(h,null)},E.prototype.copyFromFramebuffer=function(e,i,a,o,n,h){if(e=r(e,0),i=r(i,0),a=r(a,0),o=r(o,0),n=r(n,this._width),h=r(h,this._height),f.isDepthFormat(this._pixelFormat))throw new s("Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");if(this._pixelDatatype===l.FLOAT)throw new s("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");if(this._pixelDatatype===l.HALF_FLOAT)throw new s("Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.");if(f.isCompressedFormat(this._pixelFormat))throw new s("Cannot call copyFrom with a compressed texture pixel format.");t.typeOf.number.greaterThanOrEquals("xOffset",e,0),t.typeOf.number.greaterThanOrEquals("yOffset",i,0),t.typeOf.number.greaterThanOrEquals("framebufferXOffset",a,0),t.typeOf.number.greaterThanOrEquals("framebufferYOffset",o,0),t.typeOf.number.lessThanOrEquals("xOffset + width",e+n,this._width),t.typeOf.number.lessThanOrEquals("yOffset + height",i+h,this._height);var p=this._context._gl,u=this._textureTarget;p.activeTexture(p.TEXTURE0),p.bindTexture(u,this._texture),p.copyTexSubImage2D(u,0,e,i,a,o,n,h),p.bindTexture(u,null),this._initialized=!0},E.prototype.generateMipmap=function(e){if(e=r(e,_.DONT_CARE),f.isDepthFormat(this._pixelFormat))throw new s("Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");if(f.isCompressedFormat(this._pixelFormat))throw new s("Cannot call generateMipmap with a compressed pixel format.");if(this._width>1&&!h.isPowerOfTwo(this._width))throw new s("width must be a power of two to call generateMipmap().");if(this._height>1&&!h.isPowerOfTwo(this._height))throw new s("height must be a power of two to call generateMipmap().");if(!_.validate(e))throw new s("hint is invalid.");this._hasMipmap=!0;var t=this._context._gl,i=this._textureTarget;t.hint(t.GENERATE_MIPMAP_HINT,e),t.activeTexture(t.TEXTURE0),t.bindTexture(i,this._texture),t.generateMipmap(i),t.bindTexture(i,null)},E.prototype.isDestroyed=function(){return!1},E.prototype.destroy=function(){return this._context._gl.deleteTexture(this._texture),n(this)},E});