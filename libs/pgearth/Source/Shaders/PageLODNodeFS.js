define(function(){"use strict";return"uniform sampler2D u_texture;\nuniform vec4 u_bgColor;\nuniform float u_transparency;\nuniform bool u_bRGB;\nuniform bool u_useClip;\nuniform vec4 u_clipBounds;\nuniform sampler2D u_clipTexture;\nuniform bool u_usePit;\nuniform vec4 u_pitBounds;\nuniform sampler2D u_pitTexture;\nuniform bool u_useColorTable;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_colorRange;\nuniform int u_displayMode;\nuniform bool u_useOverlay;\nuniform vec4 u_overlayBounds;\nuniform sampler2D u_overlayTexture;\nvarying vec2 v_textureCoordinates;\nvarying vec3 v_vertex;\nbool isPointInBound(vec2 point, vec4 bounds) {\n    return (point.x>bounds.x&&point.x<bounds.z&&point.y<bounds.y&&point.y>bounds.w);\n}\nvoid main()\n{\n    if (u_useClip && true) { // 多边形裁剪；'&& true'是用于解决部分ati显卡崩溃的问题。\n        if (!isPointInBound(v_vertex.xy, u_clipBounds)) {\n            discard;\n            return;\n        }\n        vec2 clipTexCoord = vec2((v_vertex.x-u_clipBounds.x)/(u_clipBounds.z-u_clipBounds.x),\n        (v_vertex.y-u_clipBounds.w)/(u_clipBounds.y-u_clipBounds.w));\n        if (texture2D(u_clipTexture, clipTexCoord).x < 0.5) {\n            discard;\n            return;\n        }\n    }\n    if (u_usePit && isPointInBound(v_vertex.xy, u_pitBounds)) { // 多边形挖坑\n        vec2 pitTexCoord = vec2((v_vertex.x-u_pitBounds.x)/(u_pitBounds.z-u_pitBounds.x),\n        (v_vertex.y-u_pitBounds.w)/(u_pitBounds.y-u_pitBounds.w));\n        if (texture2D(u_pitTexture, pitTexCoord).x > 0.5) {\n            discard;\n            return;\n        }\n    }\n    vec4 heightmapColor = vec4(1.0);\n    if (u_useColorTable && u_displayMode > 0) { // 根据高度分层设色\n        heightmapColor = texture2D(u_colorTexture, vec2((v_vertex.z-u_colorRange.x)/(u_colorRange.y-u_colorRange.x), 0.5));\n        if (u_displayMode == 1) {\n            gl_FragColor = heightmapColor;\n            return;\n        }\n    }\n    vec4 color = vec4(u_transparency);\n    if (u_bgColor.r < 1.0 || u_bgColor.g < 1.0 || u_bgColor.b < 1.0 || u_bgColor.a < 1.0) {\n        color.rgb = u_bgColor.rgb;\n    } else {\n        if (u_bRGB) {\n            color.rgb = texture2D(u_texture, v_textureCoordinates).rgb;\n        } else {\n            color.rgb = texture2D(u_texture, v_textureCoordinates).bgr;\n        }\n    }\n    if (u_useOverlay && isPointInBound(v_vertex.xy, u_overlayBounds)) { // 叠加影像\n        vec2 overlayTexCoord = vec2((v_vertex.x-u_overlayBounds.x)/(u_overlayBounds.z-u_overlayBounds.x),\n        (v_vertex.y-u_overlayBounds.w)/(u_overlayBounds.y-u_overlayBounds.w));\n        vec4 overlayColor = texture2D(u_overlayTexture, overlayTexCoord);\n        color.rgb = overlayColor.rgb * overlayColor.a + color.rgb * (1.0-overlayColor.a);\n    }\n    gl_FragColor = color * heightmapColor;\n}"});